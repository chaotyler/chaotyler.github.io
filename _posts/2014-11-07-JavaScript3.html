---
layout: blog
title: 使用闭包和立即执行的方法来保存状态
---
// 这个代码是错误的，因为变量i从来就没背locked住<br />
// 相反，当循环执行以后，我们在点击的时候i才获得数值<br />
// 因为这个时候i操真正获得值<br />
// 所以说无论点击那个连接，最终显示的都是I am link #10（如果有10个a元素的话）<br />
<br />
<br />

<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
</blockquote>
<span style="background-color: rgb(153, 255, 153);">var elems = document.getElementsByTagName('a');</span><br />

<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
</blockquote>
<span style="background-color: rgb(153, 255, 153);">for (var i = 0; i &lt; elems.length; i++) {</span><br />

<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
</blockquote>
<span style="background-color: rgb(153, 255, 153);">&nbsp; &nbsp; elems[i].addEventListener('click', function (e) {</span><br />

<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
</blockquote>
<span style="background-color: rgb(153, 255, 153);">&nbsp; &nbsp; &nbsp; &nbsp; e.preventDefault();</span><br />

<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
</blockquote>
<span style="background-color: rgb(153, 255, 153);">&nbsp; &nbsp; &nbsp; &nbsp; alert('I am link #' + i);</span><br />

<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
</blockquote>
<span style="background-color: rgb(153, 255, 153);">&nbsp; &nbsp; }, 'false');</span><br />
<span style="background-color: rgb(153, 255, 153);">}</span><br />
<br />
// 这个是可以用的，因为他在自执行函数表达式闭包内部<br />
// i的值作为locked的索引存在，在循环执行结束以后，尽管最后i的值变成了a元素总数（例如10）<br />
// 但闭包内部的lockedInIndex值是没有改变，因为他已经执行完毕了<br />
// 所以当点击连接的时候，结果是正确的<br />
<br />
<br />
<span style="background-color: rgb(153, 255, 153);">var elems = document.getElementsByTagName('a');<br />
for (var i = 0; i &lt; elems.length; i++) {<br />
&nbsp; &nbsp; (function (lockedInIndex) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; elems[i].addEventListener('click', function (e) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.preventDefault();<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alert('I am link #' + lockedInIndex);<br />
&nbsp; &nbsp; &nbsp; &nbsp; }, 'false');<br />
&nbsp; &nbsp; })(i);<br />
}</span><br />
<br />
<br />
// 你也可以像下面这样应用，在处理函数那里使用自执行函数表达式<br />
// 而不是在addEventListener外部<br />
// 但是相对来说，上面的代码更具可读性<br />
<br />
<br />
<span style="background-color: rgb(153, 255, 153);">var elems = document.getElementsByTagName('a');<br />
for (var i = 0; i &lt; elems.length; i++) {<br />
&nbsp; &nbsp; elems[i].addEventListener('click', (function (lockedInIndex) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; return function (e) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.preventDefault();<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alert('I am link #' + lockedInIndex);<br />
&nbsp; &nbsp; &nbsp; &nbsp; };<br />
&nbsp; &nbsp; })(i), 'false');<br />
</span>
<p>
	<span style="background-color: rgb(153, 255, 153);">}</span>
</p>
<p>
	//也可以用闭包来保存状态
</p>
<span style="background-color: rgb(153, 255, 153);">var elems = document.getElementsByTagName('a');<br />
function keep(i){<br />
&nbsp;var keep = i;<br />
&nbsp;return function(){<br />
&nbsp; &nbsp;alert(keep);<br />
&nbsp;}<br />
}<br />
for (var i = 0; i &lt; elems.length; i++) {<br />
&nbsp; &nbsp;var index<br />
&nbsp; &nbsp; elems[i].addEventListener('click', keep(i), 'false');<br />
}</span><br />
<br />
<br />
不管那种方法，关键是看最后方法执行时是调用的哪个变量，第一种直接调用i，i是对外面可见的，所以在for后会变化，而另外三种都是调用的非i变量，而且这个非i变量在for中是不可见的，无法改变！！